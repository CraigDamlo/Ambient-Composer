<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Chord Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #581c87 50%, #0f172a 100%);
            min-height: 100vh;
            padding: 2rem;
            color: #e9d5ff;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .card {
            background: rgba(30, 27, 75, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }
        h1 { font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem; }
        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 0.5rem;
        }
        .btn-primary { background: #9333ea; color: white; }
        .btn-secondary { background: #16a34a; color: white; }
        .btn-midi { background: #0369a1; color: white; }
        .btn-play { background: #b45309; color: white; }
        .btn-play.playing { background: #991b1b; }
        .mood-btn {
            padding: 0.4rem 0.9rem;
            border: 1px solid rgba(168, 85, 247, 0.35);
            border-radius: 6px;
            background: rgba(30, 27, 75, 0.5);
            color: rgba(233, 213, 255, 0.6);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .mood-btn:hover { border-color: rgba(168, 85, 247, 0.7); color: #e9d5ff; }
        .mood-btn.active { background: rgba(147, 51, 234, 0.4); border-color: #9333ea; color: #e9d5ff; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0; }
        .control-group { display: flex; flex-direction: column; }
        label { font-size: 0.875rem; margin-bottom: 0.5rem; }
        select, input[type="range"] { 
            padding: 0.5rem; 
            background: #334155; 
            color: #e9d5ff; 
            border: 1px solid rgba(168, 85, 247, 0.3); 
            border-radius: 8px; 
        }
        .chord-item {
            padding: 1rem;
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 8px;
            margin-bottom: 0.75rem;
            display: flex;
            justify-content: space-between;
        }
        .chord-name { font-size: 1.5rem; font-weight: bold; }
        .timeline-wrapper { 
            background: rgba(15, 23, 42, 0.8); 
            border-radius: 8px; 
            padding: 1.5rem; 
            padding-left: 70px;
        }
        #timeline { 
            position: relative; 
            width: 100%;
        }
        .note-labels {
            position: absolute;
            left: -58px;
            top: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .grid-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(168, 85, 247, 0.15);
        }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        #timeline-tooltip {
            position: fixed;
            pointer-events: none;
            background: rgba(15, 10, 40, 0.92);
            border: 1px solid rgba(168, 85, 247, 0.5);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-family: monospace;
            font-size: 0.8rem;
            color: #e9d5ff;
            line-height: 1.6;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.1s ease;
            z-index: 100;
        }
        #timeline-tooltip.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="timeline-tooltip"></div>
    <div class="container">
        <div class="card">
            <h1>Ambient Chord Progression Generator</h1>
            <p style="color: rgba(233, 213, 255, 0.7); margin-bottom: 1.5rem;">
                Generate evolving chord progressions for your hardware synths
            </p>

            <!-- Mood Selectors -->
            <div style="background:rgba(15,23,42,0.4); border:1px solid rgba(168,85,247,0.2); border-radius:10px; padding:1rem; margin-bottom:1.25rem;">
                <div style="font-size:0.75rem; color:rgba(233,213,255,0.5); text-transform:uppercase; letter-spacing:0.08em; margin-bottom:0.75rem;">Quick Mood</div>
                <div style="display:flex; gap:1.5rem; flex-wrap:wrap;">
                    <div class="control-group" style="flex:1; min-width:140px;">
                        <label>Tempo Feel</label>
                        <div style="display:flex; gap:0.5rem; margin-top:0.25rem;">
                            <button class="mood-btn" id="tempoSlow" onclick="setTempo('slow')">Slow</button>
                            <button class="mood-btn active" id="tempoMid" onclick="setTempo('mid')">Mid</button>
                            <button class="mood-btn" id="tempoFast" onclick="setTempo('fast')">Fast</button>
                        </div>
                    </div>
                    <div class="control-group" style="flex:1; min-width:140px;">
                        <label>Tone</label>
                        <div style="display:flex; gap:0.5rem; margin-top:0.25rem;">
                            <button class="mood-btn" id="toneDark" onclick="setTone('dark')">Dark</button>
                            <button class="mood-btn active" id="toneNeutral" onclick="setTone('neutral')">Neutral</button>
                            <button class="mood-btn" id="toneBright" onclick="setTone('bright')">Bright</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div>
                <button class="btn-primary" onclick="generateProgression()">â†» Generate New</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Key</label>
                    <select id="key" onchange="generateProgression()">
                        <option>C</option><option>C#</option><option>D</option><option>D#</option>
                        <option>E</option><option>F</option><option>F#</option><option>G</option>
                        <option>G#</option><option>A</option><option>A#</option><option>B</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Mode</label>
                    <select id="mode" onchange="generateProgression()">
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="dorian">Dorian</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Voicing Mode</label>
                    <select id="voicingMode" onchange="updateVoicingControls(); generateProgression()">
                        <option value="fixed">Fixed</option>
                        <option value="varied">Varied</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Length: <span id="lengthVal">4</span></label>
                    <input type="range" id="length" min="2" max="8" value="4" 
                           oninput="document.getElementById('lengthVal').textContent=this.value; generateProgression()">
                </div>
                <div class="control-group">
                    <label>Change Rate: <span id="rateVal">4</span> beats</label>
                    <input type="range" id="rate" min="2" max="16" step="2" value="4"
                           oninput="document.getElementById('rateVal').textContent=this.value; generateProgression()">
                </div>
            </div>

            <div id="voicingFixed" class="control-group" style="margin-bottom: 1rem; display: none;">
                <label>Fixed Voicing Type</label>
                <select id="fixedVoicing" onchange="generateProgression()">
                    <option value="triad">Triad (3 notes)</option>
                    <option value="seventh" selected>7th (4 notes)</option>
                    <option value="ninth">9th (5 notes)</option>
                    <option value="eleventh">11th (6 notes)</option>
                </select>
            </div>

            <div id="voicingVaried" class="control-group" style="margin-bottom: 1rem; display: none;">
                <label>Voicing Complexity: <span id="varietyVal">50</span>%</label>
                <input type="range" id="variety" min="0" max="1" step="0.1" value="0.5"
                       oninput="document.getElementById('varietyVal').textContent=Math.round(this.value*100); generateProgression()">
            </div>

            <div class="control-group" style="margin-bottom: 1rem;">
                <label>Timing Complexity: <span id="complexityVal">30</span>%</label>
                <input type="range" id="complexity" min="0" max="1" step="0.1" value="0.3"
                       oninput="document.getElementById('complexityVal').textContent=Math.round(this.value*100); generateProgression()">
            </div>

            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="inversions" checked onchange="generateProgression()">
                <label for="inversions">Smart Inversions (smooth voice leading and loops)</label>
            </div>

            <div style="height:1px; background:rgba(168,85,247,0.2); margin:1.5rem 0;"></div>

            <div style="font-size:0.75rem; color:rgba(233,213,255,0.5); text-transform:uppercase; letter-spacing:0.08em; margin-bottom:0.75rem;">Bass Line</div>
            <div class="controls">
                <div class="control-group">
                    <label>Bass Style</label>
                    <select id="bassStyle" onchange="generateBassLine()">
                        <option value="root">Root Only</option>
                        <option value="rootFifth">Root + Fifth</option>
                        <option value="walking">Walking</option>
                        <option value="arpeggiated">Arpeggiated</option>
                        <option value="pedal">Pedal Point</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Bass Octave</label>
                    <select id="bassOctave" onchange="generateBassLine()">
                        <option value="1">Octave 1 (very deep)</option>
                        <option value="2" selected>Octave 2 (deep)</option>
                        <option value="3">Octave 3 (mid-bass)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Bass Density: <span id="densityVal">50</span>%</label>
                    <input type="range" id="bassDensity" min="0" max="1" step="0.1" value="0.5"
                           oninput="document.getElementById('densityVal').textContent=Math.round(this.value*100); generateBassLine()">
                </div>
                <div class="control-group">
                    <label>Syncopation: <span id="syncoVal">20</span>%</label>
                    <input type="range" id="bassSynco" min="0" max="1" step="0.1" value="0.2"
                           oninput="document.getElementById('syncoVal').textContent=Math.round(this.value*100); generateBassLine()">
                </div>
            </div>

            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="bassRests" onchange="generateBassLine()">
                <label for="bassRests">Include rests</label>
                &nbsp;&nbsp;
                <input type="checkbox" id="bassOctaveJumps" onchange="generateBassLine()">
                <label for="bassOctaveJumps">Octave jumps</label>
            </div>
        </div>

        <div class="card">
            <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">Chord Progression</h2>
            <div id="loopQuality" style="margin-bottom: 1rem; padding: 1rem; background: rgba(168, 85, 247, 0.1); border-radius: 8px;"></div>
            <div id="progressionList"></div>

            <div style="height:1px; background:rgba(56,189,248,0.2); margin:1.25rem 0;"></div>
            <div style="font-size:0.75rem; color:rgba(125,211,252,0.5); text-transform:uppercase; letter-spacing:0.08em; margin-bottom:0.75rem;">Bass Line</div>
            <div id="bassNoteContainer"></div>
        </div>

        <div class="card">
            <div style="display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:1rem; margin-bottom:1rem;">
                <h2 style="font-size: 1.5rem; font-weight: bold; margin:0;">Timeline View</h2>
                <div style="display:flex; align-items:center; gap:1rem; flex-wrap:wrap;">
                    <button class="btn-play" id="playBtn" onclick="togglePlayback()">â–¶ Play</button>
                    <div style="display:flex; align-items:center; gap:0.6rem;">
                        <label style="margin:0; font-size:0.875rem; white-space:nowrap;">BPM: <span id="bpmVal">60</span></label>
                        <input type="range" id="bpm" min="20" max="120" value="60" style="width:110px;"
                               oninput="document.getElementById('bpmVal').textContent=this.value">
                    </div>
                    <div style="display:flex; align-items:center; gap:0.4rem; font-size:0.875rem;">
                        <input type="checkbox" id="loopPlayback" checked>
                        <label for="loopPlayback" style="margin:0;">Loop</label>
                    </div>
                </div>
            </div>

            <!-- ADSR Controls -->
            <div style="background:rgba(15,23,42,0.4); border:1px solid rgba(168,85,247,0.2); border-radius:10px; padding:1rem; margin-bottom:1rem;">
                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.75rem;">
                    <div style="font-size:0.75rem; color:rgba(233,213,255,0.5); text-transform:uppercase; letter-spacing:0.08em;">Envelope (Chords)</div>
                    <div style="display:flex; align-items:center; gap:0.4rem; font-size:0.8rem; color:rgba(233,213,255,0.7);">
                        <input type="checkbox" id="tieNotes" checked>
                        <label for="tieNotes" style="margin:0; cursor:pointer;">Sustain Repeated Notes</label>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns:repeat(4,1fr); gap:1rem;">
                    <div class="control-group">
                        <label>Attack: <span id="attackVal">1.5</span>s</label>
                        <input type="range" id="envAttack" min="0.01" max="4" step="0.01" value="1.5"
                               oninput="document.getElementById('attackVal').textContent=parseFloat(this.value).toFixed(2)">
                    </div>
                    <div class="control-group">
                        <label>Decay: <span id="decayVal">0.5</span>s</label>
                        <input type="range" id="envDecay" min="0.01" max="3" step="0.01" value="0.5"
                               oninput="document.getElementById('decayVal').textContent=parseFloat(this.value).toFixed(2)">
                    </div>
                    <div class="control-group">
                        <label>Sustain: <span id="sustainVal">80</span>%</label>
                        <input type="range" id="envSustain" min="0" max="1" step="0.01" value="0.8"
                               oninput="document.getElementById('sustainVal').textContent=Math.round(this.value*100)">
                    </div>
                    <div class="control-group">
                        <label>Release: <span id="releaseVal">2.0</span>s</label>
                        <input type="range" id="envRelease" min="0.01" max="5" step="0.01" value="2.0"
                               oninput="document.getElementById('releaseVal').textContent=parseFloat(this.value).toFixed(2)">
                    </div>
                </div>
            </div>

            <div style="display:flex; gap:1.5rem; margin-bottom:1rem; font-size:0.8rem; color:rgba(233,213,255,0.6);">
                <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#8b5cf6;margin-right:5px;vertical-align:middle;"></span>Chords</span>
                <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#38bdf8;margin-right:5px;vertical-align:middle;"></span>Bass</span>
            </div>
            <div class="timeline-wrapper">
                <div id="timeline">
                    <canvas id="canvas"></canvas>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem;">Export</h2>
            <p style="color: rgba(233, 213, 255, 0.6); font-size: 0.875rem; margin-bottom: 1.25rem;">Export the current progression and bass line for use in your DAW or sequencer.</p>
            <div style="display:flex; gap:0.75rem; flex-wrap:wrap;">
                <button class="btn-secondary" onclick="exportProgression()">ðŸ“‹ Copy to Clipboard</button>
                <button class="btn-midi" onclick="exportMidi()">â¬‡ Download MIDI</button>
            </div>
        </div>
    </div>

    <script>
        let progression = [];
        let bassLine = [];
        let timelineHitTargets = []; // { x, y, label, isBass }
        
        const chordLibrary = {
            major: {
                I: { triad: [0,4,7], seventh: [0,4,7,11], ninth: [0,4,7,11,14], eleventh: [0,4,7,11,14,17] },
                ii: { triad: [2,5,9], seventh: [2,5,9,12], ninth: [2,5,9,12,16], eleventh: [2,5,9,12,16,19] },
                iii: { triad: [4,7,11], seventh: [4,7,11,14], ninth: [4,7,11,14,16], eleventh: [4,7,11,14,16,19] },
                IV: { triad: [5,9,12], seventh: [5,9,12,16], ninth: [5,9,12,16,19], eleventh: [5,9,12,16,19,22] },
                V: { triad: [7,11,14], seventh: [7,11,14,17], ninth: [7,11,14,17,21], eleventh: [7,11,14,17,21,24] },
                vi: { triad: [9,12,16], seventh: [9,12,16,19], ninth: [9,12,16,19,21], eleventh: [9,12,16,19,21,24] },
                'viiÂ°': { triad: [11,14,17], seventh: [11,14,17,20], ninth: [11,14,17,20,23], eleventh: [11,14,17,20,23,26] }
            },
            minor: {
                i: { triad: [0,3,7], seventh: [0,3,7,10], ninth: [0,3,7,10,14], eleventh: [0,3,7,10,14,17] },
                'iiÂ°': { triad: [2,5,8], seventh: [2,5,8,12], ninth: [2,5,8,12,15], eleventh: [2,5,8,12,15,19] },
                III: { triad: [3,7,10], seventh: [3,7,10,14], ninth: [3,7,10,14,17], eleventh: [3,7,10,14,17,20] },
                iv: { triad: [5,8,12], seventh: [5,8,12,15], ninth: [5,8,12,15,19], eleventh: [5,8,12,15,19,22] },
                v: { triad: [7,10,14], seventh: [7,10,14,17], ninth: [7,10,14,17,19], eleventh: [7,10,14,17,19,22] },
                VI: { triad: [8,12,15], seventh: [8,12,15,19], ninth: [8,12,15,19,22], eleventh: [8,12,15,19,22,24] },
                VII: { triad: [10,14,17], seventh: [10,14,17,20], ninth: [10,14,17,20,22], eleventh: [10,14,17,20,22,24] }
            },
            dorian: {
                i: { triad: [0,3,7], seventh: [0,3,7,10], ninth: [0,3,7,10,14], eleventh: [0,3,7,10,14,17] },
                ii: { triad: [2,5,9], seventh: [2,5,9,12], ninth: [2,5,9,12,16], eleventh: [2,5,9,12,16,19] },
                III: { triad: [3,7,10], seventh: [3,7,10,14], ninth: [3,7,10,14,17], eleventh: [3,7,10,14,17,19] },
                IV: { triad: [5,9,12], seventh: [5,9,12,16], ninth: [5,9,12,16,19], eleventh: [5,9,12,16,19,21] },
                v: { triad: [7,10,14], seventh: [7,10,14,17], ninth: [7,10,14,17,19], eleventh: [7,10,14,17,19,21] },
                'viÂ°': { triad: [9,12,15], seventh: [9,12,15,19], ninth: [9,12,15,19,21], eleventh: [9,12,15,19,21,24] },
                VII: { triad: [10,14,17], seventh: [10,14,17,21], ninth: [10,14,17,21,24], eleventh: [10,14,17,21,24,26] }
            }
        };

        const commonProgressions = {
            major: [['I','V','vi','IV'], ['I','vi','IV','V'], ['I','IV','V','IV'], ['vi','IV','I','V']],
            minor: [['i','VI','III','VII'], ['i','iv','VII','VI'], ['i','VI','VII','i']],
            dorian: [['i','IV','i','IV'], ['i','ii','IV','i'], ['i','VII','IV','i']]
        };

        function noteToMidi(note, octave = 3) {
            const map = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
            return map[note] + (octave + 1) * 12;
        }

        function midiToNote(midi) {
            const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            return notes[midi % 12] + (Math.floor(midi / 12) - 1);
        }

        function noteNameToMidi(name) {
            const match = name.match(/([A-G]#?)(\d+)/);
            if (!match) return 60;
            const map = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
            return map[match[1]] + (parseInt(match[2]) + 1) * 12;
        }

        function findBestInversion(chord, prevChord) {
            if (!prevChord || prevChord.length === 0) return chord;
            const inversions = [];
            for (let i = 0; i < chord.length; i++) {
                const inv = [...chord];
                for (let j = 0; j < i; j++) inv.push(inv.shift() + 12);
                inversions.push(inv);
            }
            let best = inversions[0], minDist = Infinity;
            inversions.forEach(inv => {
                let dist = 0;
                const voices = Math.min(inv.length, prevChord.length);
                for (let i = 0; i < voices; i++) dist += Math.abs(inv[i] - prevChord[i]);
                if (dist < minDist) { minDist = dist; best = inv; }
            });
            return best;
        }

        // â”€â”€ Mood Presets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        let currentTempo = 'mid';
        let currentTone  = 'neutral';

        const tempoPresets = {
            slow: { bpm: 50,  rate: 8,  complexity: 0.1, bassStyle: 'root',       bassD: 0.4, synco: 0.1, attack: 2.5, release: 3.5 },
            mid:  { bpm: 70,  rate: 4,  complexity: 0.3, bassStyle: 'rootFifth',  bassD: 0.6, synco: 0.2, attack: 1.2, release: 2.0 },
            fast: { bpm: 100, rate: 2,  complexity: 0.6, bassStyle: 'walking',    bassD: 0.8, synco: 0.4, attack: 0.4, release: 0.8 },
        };

        const tonePresets = {
            dark:    { mode: 'minor',  voicingMode: 'fixed', fixedVoicing: 'ninth',    variety: 0.3, decay: 0.8, sustain: 0.7 },
            neutral: { mode: 'dorian', voicingMode: 'varied', fixedVoicing: 'seventh', variety: 0.5, decay: 0.5, sustain: 0.8 },
            bright:  { mode: 'major',  voicingMode: 'fixed', fixedVoicing: 'eleventh', variety: 0.7, decay: 0.3, sustain: 0.9 },
        };

        function setTempo(tempo) {
            currentTempo = tempo;
            ['slow','mid','fast'].forEach(t =>
                document.getElementById('tempo' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tempo)
            );
            applyMoodPresets();
        }

        function setTone(tone) {
            currentTone = tone;
            ['dark','neutral','bright'].forEach(t =>
                document.getElementById('tone' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tone)
            );
            applyMoodPresets();
        }

        function applyMoodPresets() {
            const tp = tempoPresets[currentTempo];
            const tn = tonePresets[currentTone];

            // BPM
            document.getElementById('bpm').value = tp.bpm;
            document.getElementById('bpmVal').textContent = tp.bpm;

            // Rate & complexity
            document.getElementById('rate').value = tp.rate;
            document.getElementById('rateVal').textContent = tp.rate;
            document.getElementById('complexity').value = tp.complexity;
            document.getElementById('complexityVal').textContent = Math.round(tp.complexity * 100);

            // Bass
            document.getElementById('bassStyle').value = tp.bassStyle;
            document.getElementById('bassDensity').value = tp.bassD;
            document.getElementById('densityVal').textContent = Math.round(tp.bassD * 100);
            document.getElementById('bassSynco').value = tp.synco;
            document.getElementById('syncoVal').textContent = Math.round(tp.synco * 100);

            // ADSR
            document.getElementById('envAttack').value = tp.attack;
            document.getElementById('attackVal').textContent = tp.attack.toFixed(2);
            document.getElementById('envDecay').value = tn.decay;
            document.getElementById('decayVal').textContent = tn.decay.toFixed(2);
            document.getElementById('envSustain').value = tn.sustain;
            document.getElementById('sustainVal').textContent = Math.round(tn.sustain * 100);
            document.getElementById('envRelease').value = tp.release;
            document.getElementById('releaseVal').textContent = tp.release.toFixed(2);

            // Mode & voicing
            document.getElementById('mode').value = tn.mode;
            document.getElementById('voicingMode').value = tn.voicingMode;
            document.getElementById('fixedVoicing').value = tn.fixedVoicing;
            document.getElementById('variety').value = tn.variety;
            document.getElementById('varietyVal').textContent = Math.round(tn.variety * 100);
            updateVoicingControls();

            generateProgression();
        }

        function updateVoicingControls() {
            const mode = document.getElementById('voicingMode').value;
            document.getElementById('voicingFixed').style.display = mode === 'fixed' ? 'block' : 'none';
            document.getElementById('voicingVaried').style.display = mode === 'varied' ? 'block' : 'none';
        }

        // â”€â”€â”€ BASS LINE GENERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function getChordMidiNotes(chord, octave) {
            // chord.notes are strings like "C3", "E3"...
            // We re-map them to the requested bass octave
            return chord.notes.map(n => {
                const match = n.match(/([A-G]#?)(\d+)/);
                const map = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
                return map[match[1]] + (parseInt(octave) + 1) * 12;
            });
        }

        function generateBassLine() {
            if (progression.length === 0) return;

            const style = document.getElementById('bassStyle').value;
            const octave = parseInt(document.getElementById('bassOctave').value);
            const density = parseFloat(document.getElementById('bassDensity').value);
            const synco = parseFloat(document.getElementById('bassSynco').value);
            const useRests = document.getElementById('bassRests').checked;
            const useOctaveJumps = document.getElementById('bassOctaveJumps').checked;

            bassLine = [];

            progression.forEach(chord => {
                const rootMidi = noteToMidi(document.getElementById('key').value, octave)
                    + chordLibrary[document.getElementById('mode').value][chord.name].triad[0];
                const fifthMidi = rootMidi + 7;
                const thirdMidi = rootMidi + (document.getElementById('mode').value === 'major' ? 4 : 3);
                const chordTones = [rootMidi, thirdMidi, fifthMidi];
                const duration = chord.duration;

                // Build a list of sub-notes within this chord's duration
                const notes = [];
                let beat = 0;

                if (style === 'root') {
                    // One note per chord, whole duration
                    notes.push({ midi: rootMidi, duration, type: 'root', rest: false });
                }
                else if (style === 'rootFifth') {
                    // Alternate root and fifth on half-durations
                    const half = Math.max(1, Math.floor(duration / 2));
                    notes.push({ midi: rootMidi, duration: half, type: 'root', rest: false });
                    notes.push({ midi: fifthMidi, duration: duration - half, type: '5th', rest: false });
                }
                else if (style === 'walking') {
                    // Walk down/up chord tones per beat
                    let remaining = duration;
                    let dir = Math.random() < 0.5 ? 1 : -1;
                    let pos = 0;
                    while (remaining > 0) {
                        const noteDur = Math.random() < synco ? 1 : 2;
                        const dur = Math.min(noteDur, remaining);
                        const isRest = useRests && Math.random() < (1 - density) * 0.4;
                        const midi = chordTones[((pos % chordTones.length) + chordTones.length) % chordTones.length];
                        const octJump = useOctaveJumps && Math.random() < 0.12;
                        notes.push({ midi: midi + (octJump ? 12 : 0), duration: dur, type: 'walk', rest: isRest });
                        pos += dir;
                        if (Math.random() < 0.3) dir *= -1;
                        remaining -= dur;
                    }
                }
                else if (style === 'arpeggiated') {
                    let remaining = duration;
                    let pos = 0;
                    while (remaining > 0) {
                        const noteDur = Math.random() < synco ? 1 : 2;
                        const dur = Math.min(noteDur, remaining);
                        const isRest = useRests && Math.random() < (1 - density) * 0.35;
                        const toneIdx = pos % chordTones.length;
                        const octShift = useOctaveJumps && pos >= chordTones.length ? 12 : 0;
                        notes.push({ midi: chordTones[toneIdx] + octShift, duration: dur, type: 'arp', rest: isRest });
                        pos++;
                        remaining -= dur;
                    }
                }
                else if (style === 'pedal') {
                    // Root on beat 1, rests/skips otherwise
                    let remaining = duration;
                    notes.push({ midi: rootMidi, duration: 2, type: 'pedal', rest: false });
                    remaining -= 2;
                    while (remaining > 0) {
                        const dur = Math.min(2, remaining);
                        const isRest = Math.random() < (1 - density * 0.7);
                        notes.push({ midi: rootMidi + (useOctaveJumps && !isRest && Math.random() < 0.3 ? 12 : 0), duration: dur, type: 'pedal', rest: isRest });
                        remaining -= dur;
                    }
                }

                bassLine.push(...notes);
            });

            displayBassLine();
            drawTimeline(); // redraw combined view
        }

        function displayBassLine() {
            const container = document.getElementById('bassNoteContainer');
            container.innerHTML = `<div style="font-family: monospace; font-size: 1rem; color: #7dd3fc; line-height: 2; letter-spacing: 0.02em; flex-wrap: wrap; display: flex; gap: 0.5rem;">` +
                bassLine.map(n => {
                    if (n.rest) return `<span style="color: rgba(125,211,252,0.35);">â€” (${n.duration})</span>`;
                    return `<span style="background: rgba(14,165,233,0.12); border: 1px solid rgba(56,189,248,0.25); border-radius: 6px; padding: 0.2rem 0.5rem;">${midiToNote(n.midi)} <span style="color:rgba(125,211,252,0.55); font-size:0.85em;">(${n.duration})</span></span>`;
                }).join('') +
            `</div>`;
        }

        // â”€â”€â”€ CHORD PROGRESSION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function generateProgression() {
            const key = document.getElementById('key').value;
            const mode = document.getElementById('mode').value;
            const voicingMode = document.getElementById('voicingMode').value;
            const fixedVoicing = document.getElementById('fixedVoicing').value;
            const variety = parseFloat(document.getElementById('variety').value);
            const length = parseInt(document.getElementById('length').value);
            const rate = parseInt(document.getElementById('rate').value);
            const complexity = parseFloat(document.getElementById('complexity').value);
            const useInversions = document.getElementById('inversions').checked;

            const baseProgression = commonProgressions[mode][Math.floor(Math.random() * commonProgressions[mode].length)];
            const rootMidi = noteToMidi(key);
            const voicingTypes = ['triad', 'seventh', 'ninth', 'eleventh'];
            const chordsToUse = baseProgression.slice(0, length);

            const tempChords = [];
            chordsToUse.forEach(chordName => {
                const voicings = chordLibrary[mode][chordName];
                let selectedVoicing;
                if (voicingMode === 'fixed') {
                    selectedVoicing = fixedVoicing;
                } else if (voicingMode === 'varied') {
                    const r = Math.random();
                    if (r < (1 - variety) * 0.5) selectedVoicing = 'triad';
                    else if (r < (1 - variety) * 0.7 + variety * 0.3) selectedVoicing = 'seventh';
                    else if (r < (1 - variety) * 0.85 + variety * 0.6) selectedVoicing = 'ninth';
                    else selectedVoicing = 'eleventh';
                } else {
                    selectedVoicing = voicingTypes[Math.floor(Math.random() * voicingTypes.length)];
                }
                const intervals = voicings[selectedVoicing];
                const midi = intervals.map(i => rootMidi + i);
                let duration = rate;
                if (Math.random() < complexity) duration = [2, 4, 8][Math.floor(Math.random() * 3)];
                tempChords.push({ name: chordName, voicing: selectedVoicing, rootMidi: midi, duration });
            });

            if (useInversions && tempChords.length > 1) {
                let bestSeq = null, bestDist = Infinity;
                for (let firstInv = 0; firstInv < tempChords[0].rootMidi.length; firstInv++) {
                    const first = [...tempChords[0].rootMidi];
                    for (let i = 0; i < firstInv; i++) first.push(first.shift() + 12);
                    const seq = [first];
                    let totalDist = 0;
                    for (let i = 1; i < tempChords.length; i++) {
                        const next = findBestInversion(tempChords[i].rootMidi, seq[i - 1]);
                        seq.push(next);
                        const voices = Math.min(seq[i - 1].length, next.length);
                        for (let v = 0; v < voices; v++) totalDist += Math.abs(next[v] - seq[i - 1][v]);
                    }
                    const last = seq[seq.length - 1];
                    const voices = Math.min(last.length, first.length);
                    for (let v = 0; v < voices; v++) totalDist += Math.abs(first[v] - last[v]);
                    if (totalDist < bestDist) { bestDist = totalDist; bestSeq = seq.map(s => [...s]); }
                }
                if (bestSeq) {
                    progression = tempChords.map((chord, idx) => {
                        const midi = bestSeq[idx];
                        const lowest = midi[0] % 12, root = chord.rootMidi[0] % 12;
                        let inversion = 'root';
                        if (lowest !== root) {
                            const invIdx = chord.rootMidi.findIndex(n => (n % 12) === lowest);
                            if (invIdx === 1) inversion = '1st';
                            else if (invIdx === 2) inversion = '2nd';
                            else if (invIdx === 3) inversion = '3rd';
                            else if (invIdx > 0) inversion = invIdx + 'th';
                        }
                        return { name: chord.name, notes: midi.map(midiToNote), voicing: chord.voicing, inversion, duration: chord.duration };
                    });
                }
            } else {
                progression = tempChords.map(chord => ({
                    name: chord.name, notes: chord.rootMidi.map(midiToNote),
                    voicing: chord.voicing, inversion: 'root', duration: chord.duration
                }));
            }

            displayProgression();
            drawTimeline();
            generateBassLine(); // auto-regenerate bass line when chords change
        }

        function displayProgression() {
            const list = document.getElementById('progressionList');
            const useInv = document.getElementById('inversions').checked;
            list.innerHTML = progression.map(c => `
                <div class="chord-item">
                    <div>
                        <span class="chord-name">${c.name}</span>
                        <span style="color: #d8b4fe; margin-left: 1rem;">${c.notes.join(' - ')}</span>
                        <span style="color: rgba(233,213,255,0.6); font-size: 0.875rem; margin-left: 0.75rem;">
                            (${c.voicing}${useInv ? ', ' + c.inversion + ' inv' : ''})
                        </span>
                    </div>
                    <div style="font-family: monospace; color: #d8b4fe;">${c.duration} beats</div>
                </div>
            `).join('');
            
            if (progression.length > 0 && useInv) {
                const first = progression[0].notes.map(noteNameToMidi);
                const last = progression[progression.length - 1].notes.map(noteNameToMidi);
                let totalDist = 0;
                const voices = Math.min(first.length, last.length);
                for (let i = 0; i < voices; i++) totalDist += Math.abs(first[i] - last[i]);
                const avgDist = (totalDist / voices).toFixed(1);
                const quality = document.getElementById('loopQuality');
                if (avgDist < 3) {
                    quality.innerHTML = `<strong>Loop Quality: Excellent âœ“</strong><br>Average distance: ${avgDist} semitones (very smooth loop)`;
                    quality.style.background = 'rgba(34, 197, 94, 0.2)';
                } else if (avgDist < 6) {
                    quality.innerHTML = `<strong>Loop Quality: Good</strong><br>Average distance: ${avgDist} semitones (smooth loop)`;
                    quality.style.background = 'rgba(234, 179, 8, 0.2)';
                } else {
                    quality.innerHTML = `<strong>Loop Quality: Fair</strong><br>Average distance: ${avgDist} semitones (moderate jump)`;
                    quality.style.background = 'rgba(239, 68, 68, 0.2)';
                }
                const details = [];
                for (let i = 0; i < voices; i++) details.push(`Voice ${i + 1}: ${Math.abs(first[i] - last[i])} semitones`);
                quality.innerHTML += `<br><span style="font-size: 0.875rem; color: rgba(233, 213, 255, 0.7);">${details.join(' â€¢ ')}</span>`;
            } else {
                document.getElementById('loopQuality').innerHTML = '';
            }
        }

        function drawTimeline() {
            if (progression.length === 0) return;
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('timeline');
            const width = container.clientWidth || 800;
            const padding = 10;

            // Collect all midi values â€” chords + bass
            let allMidi = [];
            progression.forEach(c => c.notes.forEach(n => allMidi.push(noteNameToMidi(n))));
            bassLine.forEach(n => { if (!n.rest) allMidi.push(n.midi); });
            const minNote = Math.min(...allMidi) - 1, maxNote = Math.max(...allMidi) + 1;
            const noteCount = maxNote - minNote + 1;

            // Height: clamp row height so total never exceeds ~380px or goes below readable
            const rowH = Math.min(28, Math.max(14, Math.floor(340 / noteCount)));
            const height = noteCount * rowH;

            canvas.width = width;
            canvas.height = height;
            container.style.height = height + 'px';
            ctx.clearRect(0, 0, width, height);

            const totalBeats = progression.reduce((sum, c) => sum + c.duration, 0);
            const toY = midi => ((maxNote - midi) / (maxNote - minNote)) * height;

            // â”€â”€ Divider between bass and chord register â”€â”€
            const bassMax = bassLine.filter(n => !n.rest).reduce((m, n) => Math.max(m, n.midi), 0);
            const chordMin = Math.min(...progression.flatMap(c => c.notes.map(noteNameToMidi)));
            if (bassMax > 0 && bassMax < chordMin) {
                const dividerY = (toY(bassMax) + toY(chordMin)) / 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.07)';
                ctx.lineWidth = 1;
                ctx.setLineDash([6, 5]);
                ctx.beginPath();
                ctx.moveTo(0, dividerY);
                ctx.lineTo(width, dividerY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // â”€â”€ Chord voice lines â€” drawn as duration bars with connecting lines â”€â”€
            let time = 0;
            const positions = progression.map(c => {
                const x    = padding + (time / totalBeats) * (width - padding * 2);
                time += c.duration;
                const xEnd = padding + (time / totalBeats) * (width - padding * 2);
                const notes = c.notes.map(n => {
                    const midi = noteNameToMidi(n);
                    return { midi, y: toY(midi) };
                });
                return { x, xEnd, notes, chord: c };
            });

            const dotR = Math.max(3, Math.min(5, rowH / 4));
            timelineHitTargets = [];

            // First pass: sustain bars (drawn under everything)
            positions.forEach(pos => {
                pos.notes.forEach(note => {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.12)';
                    ctx.beginPath();
                    ctx.roundRect
                        ? ctx.roundRect(pos.x, note.y - dotR, pos.xEnd - pos.x, dotR * 2, dotR)
                        : ctx.rect(pos.x, note.y - dotR, pos.xEnd - pos.x, dotR * 2);
                    ctx.fill();
                });
            });

            // Second pass: connecting lines between chord changes (start of next to end of prev at same voice)
            ctx.lineWidth = 1.5;
            for (let i = 0; i < positions.length - 1; i++) {
                const curr = positions[i], next = positions[i + 1];
                const voices = Math.min(curr.notes.length, next.notes.length);
                for (let v = 0; v < voices; v++) {
                    if (Math.abs(curr.notes[v].y - next.notes[v].y) > 1) {
                        const grad = ctx.createLinearGradient(curr.xEnd, curr.notes[v].y, next.x, next.notes[v].y);
                        grad.addColorStop(0, 'rgba(168, 85, 247, 0.6)');
                        grad.addColorStop(1, 'rgba(139, 92, 246, 0.6)');
                        ctx.strokeStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(curr.xEnd, curr.notes[v].y);
                        ctx.lineTo(next.x, next.notes[v].y);
                        ctx.stroke();
                    }
                }
            }

            // Third pass: dots + hit targets
            positions.forEach((pos, chordIdx) => {
                const chord = pos.chord;
                pos.notes.forEach((note, voiceIdx) => {
                    // Start dot
                    ctx.fillStyle = 'rgba(168, 85, 247, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pos.x, note.y, dotR + 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8b5cf6';
                    ctx.beginPath();
                    ctx.arc(pos.x, note.y, dotR, 0, Math.PI * 2);
                    ctx.fill();
                    // End cap dot
                    ctx.fillStyle = 'rgba(168, 85, 247, 0.18)';
                    ctx.beginPath();
                    ctx.arc(pos.xEnd, note.y, dotR + 1, 0, Math.PI * 2);
                    ctx.fill();

                    timelineHitTargets.push({
                        x: pos.x, y: note.y, r: dotR + 6,
                        isBass: false,
                        label: `${chord.name}  â€¢  ${midiToNote(note.midi)}\nVoice ${voiceIdx + 1}  â€¢  ${chord.voicing}, ${chord.inversion} inv\n${chord.duration} beats`
                    });
                });
            });

            // â”€â”€ Bass line notes â”€â”€
            if (bassLine.length > 0) {
                const bassTotalBeats = bassLine.reduce((s, n) => s + n.duration, 0);
                let bx = padding;

                // First pass: sustain bars
                bassLine.forEach(note => {
                    const bw = (note.duration / bassTotalBeats) * (width - padding * 2);
                    if (!note.rest) {
                        const by = toY(note.midi);
                        ctx.fillStyle = 'rgba(14, 165, 233, 0.12)';
                        ctx.beginPath();
                        ctx.roundRect
                            ? ctx.roundRect(bx, by - dotR, bw, dotR * 2, dotR)
                            : ctx.rect(bx, by - dotR, bw, dotR * 2);
                        ctx.fill();
                    }
                    bx += bw;
                });

                // Second pass: connecting lines between notes (end of one to start of next)
                const bassSegments = [];
                bx = padding;
                bassLine.forEach(note => {
                    const bw = (note.duration / bassTotalBeats) * (width - padding * 2);
                    if (!note.rest) bassSegments.push({ x: bx, xEnd: bx + bw, y: toY(note.midi) });
                    bx += bw;
                });
                ctx.lineWidth = 1.5;
                for (let i = 0; i < bassSegments.length - 1; i++) {
                    const curr = bassSegments[i], next = bassSegments[i + 1];
                    if (Math.abs(curr.y - next.y) > 1) {
                        const grad = ctx.createLinearGradient(curr.xEnd, curr.y, next.x, next.y);
                        grad.addColorStop(0, 'rgba(56, 189, 248, 0.6)');
                        grad.addColorStop(1, 'rgba(14, 165, 233, 0.6)');
                        ctx.strokeStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(curr.xEnd, curr.y);
                        ctx.lineTo(next.x, next.y);
                        ctx.stroke();
                    }
                }

                // Third pass: dots, labels, hit targets
                bx = padding;
                bassLine.forEach((note, bassIdx) => {
                    const bw = (note.duration / bassTotalBeats) * (width - padding * 2);
                    if (!note.rest) {
                        const by = toY(note.midi);

                        // Start dot
                        ctx.fillStyle = 'rgba(14, 165, 233, 0.3)';
                        ctx.beginPath();
                        ctx.arc(bx, by, dotR + 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#38bdf8';
                        ctx.beginPath();
                        ctx.arc(bx, by, dotR, 0, Math.PI * 2);
                        ctx.fill();

                        // End cap dot
                        ctx.fillStyle = 'rgba(14, 165, 233, 0.18)';
                        ctx.beginPath();
                        ctx.arc(bx + bw, by, dotR + 1, 0, Math.PI * 2);
                        ctx.fill();

                        if (rowH >= 16) {
                            ctx.fillStyle = 'rgba(125, 211, 252, 0.75)';
                            ctx.font = `${Math.max(8, rowH - 6)}px monospace`;
                            ctx.fillText(midiToNote(note.midi), bx + dotR + 6, by + 4);
                        }

                        timelineHitTargets.push({
                            x: bx, y: by, r: dotR + 8,
                            isBass: true,
                            label: `Bass  â€¢  ${midiToNote(note.midi)}\n${note.type}  â€¢  ${note.duration} beat${note.duration !== 1 ? 's' : ''}`
                        });
                    }
                    bx += bw;
                });
            }

            // â”€â”€ Labels & grid â”€â”€
            const timeline = document.getElementById('timeline');
            timeline.querySelectorAll('.note-labels, .grid-line').forEach(el => el.remove());

            const labelDiv = document.createElement('div');
            labelDiv.className = 'note-labels';
            for (let midi = maxNote; midi >= minNote; midi--) {
                const label = document.createElement('div');
                label.textContent = midiToNote(midi);
                const isBass = bassLine.some(n => !n.rest && n.midi === midi);
                const isChord = progression.some(c => c.notes.some(n => noteNameToMidi(n) === midi));
                label.style.color = isBass && !isChord ? '#7dd3fc' : '#d8b4fe';
                label.style.fontSize = Math.max(8, rowH - 6) + 'px';
                label.style.fontFamily = 'monospace';
                label.style.lineHeight = rowH + 'px';
                labelDiv.appendChild(label);
            }
            timeline.appendChild(labelDiv);

            for (let midi = maxNote; midi >= minNote; midi--) {
                const line = document.createElement('div');
                line.className = 'grid-line';
                line.style.top = toY(midi) + 'px';
                timeline.appendChild(line);
            }
        }

        function exportProgression() {
            const useInv = document.getElementById('inversions').checked;
            const key = document.getElementById('key').value;
            const mode = document.getElementById('mode').value;
            const bassStyle = document.getElementById('bassStyle').value;
            const bassOctave = document.getElementById('bassOctave').value;

            const chordText = `Key: ${key} ${mode}
Smart Inversions: ${useInv ? 'Enabled' : 'Disabled'}
Total Loop Length: ${progression.reduce((s, c) => s + c.duration, 0)} beats

Chord Progression:
${progression.map((c, i) => `${i + 1}. ${c.name} [${c.voicing}${useInv ? ', ' + c.inversion + ' inv' : ''}] - ${c.notes.join(', ')} - ${c.duration} beats`).join('\n')}`;

            const bassText = bassLine.length > 0 ? `

Bass Line (style: ${bassStyle}, octave: ${bassOctave}):
${bassLine.map((n, i) => n.rest ? `${i + 1}. REST - ${n.duration} beats` : `${i + 1}. ${midiToNote(n.midi)} [${n.type}] - ${n.duration} beats`).join('\n')}` : '';

            navigator.clipboard.writeText(chordText + bassText).then(() => {
                alert('Copied to clipboard!');
            }).catch(() => {
                alert('Could not copy to clipboard');
            });
        }

        updateVoicingControls();
        applyMoodPresets(); // applies slow + dark defaults and generates

        // â”€â”€ MIDI Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function exportMidi() {
            if (progression.length === 0) return;

            const bpm = parseInt(document.getElementById('bpm').value);
            const PPQ = 480; // pulses per quarter note
            const uspb = Math.round(60_000_000 / bpm); // microseconds per beat

            // â”€â”€ Helpers to write MIDI bytes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            function varLen(n) {
                // Encode n as MIDI variable-length quantity
                const bytes = [];
                bytes.push(n & 0x7F);
                n >>= 7;
                while (n > 0) { bytes.unshift((n & 0x7F) | 0x80); n >>= 7; }
                return bytes;
            }

            function word16(n) { return [(n >> 8) & 0xFF, n & 0xFF]; }
            function word32(n) { return [(n >> 24) & 0xFF, (n >> 16) & 0xFF, (n >> 8) & 0xFF, n & 0xFF]; }

            function makeTrack(events) {
                // events: [{ tick, type, data[] }]  sorted by tick
                events.sort((a, b) => a.tick - b.tick);

                const body = [];
                let cursor = 0;
                events.forEach(ev => {
                    const delta = ev.tick - cursor;
                    cursor = ev.tick;
                    body.push(...varLen(delta), ...ev.data);
                });
                // End of track
                body.push(0x00, 0xFF, 0x2F, 0x00);

                return [
                    0x4D, 0x54, 0x72, 0x6B,   // "MTrk"
                    ...word32(body.length),
                    ...body
                ];
            }

            // â”€â”€ Track 0: Tempo map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            const tempoTrack = makeTrack([
                { tick: 0, data: [0xFF, 0x51, 0x03, ...[(uspb >> 16) & 0xFF, (uspb >> 8) & 0xFF, uspb & 0xFF]] },
                { tick: 0, data: [0xFF, 0x03, ...stringBytes('Ambient Composer')] },
            ]);

            function stringBytes(s) {
                const b = [];
                for (let i = 0; i < s.length; i++) b.push(s.charCodeAt(i));
                return [...varLen(b.length), ...b];
            }

            // â”€â”€ Track 1: Chords (channel 0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            const chordEvents = [];
            const chordVelocity = 80;
            let tick = 0;

            progression.forEach(chord => {
                const durationTicks = chord.duration * PPQ;
                const midiNotes = chord.notes.map(noteNameToMidi);

                midiNotes.forEach(midi => {
                    chordEvents.push({ tick, data: [0x90, midi, chordVelocity] });           // note on  ch1
                    chordEvents.push({ tick: tick + durationTicks - 1, data: [0x80, midi, 0] }); // note off ch1
                });
                tick += durationTicks;
            });

            // Track name
            chordEvents.push({ tick: 0, data: [0xFF, 0x03, ...stringBytes('Chords')] });

            const chordTrack = makeTrack(chordEvents);

            // â”€â”€ Track 2: Bass (channel 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            const bassEvents = [];
            const bassVelocity = 95;
            tick = 0;

            bassLine.forEach(note => {
                const durationTicks = note.duration * PPQ;
                if (!note.rest) {
                    bassEvents.push({ tick, data: [0x91, note.midi, bassVelocity] });
                    bassEvents.push({ tick: tick + durationTicks - 1, data: [0x81, note.midi, 0] });
                }
                tick += durationTicks;
            });

            bassEvents.push({ tick: 0, data: [0xFF, 0x03, ...stringBytes('Bass')] });
            // Channel 1 program change â†’ Electric Bass (finger) = patch 33
            bassEvents.push({ tick: 0, data: [0xC1, 33] });

            const bassTrack = makeTrack(bassEvents);

            // â”€â”€ Assemble MIDI file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            const numTracks = 3;
            const header = [
                0x4D, 0x54, 0x68, 0x64,  // "MThd"
                0x00, 0x00, 0x00, 0x06,  // chunk length = 6
                0x00, 0x01,              // format 1 (multi-track)
                ...word16(numTracks),
                ...word16(PPQ),
            ];

            const midi = new Uint8Array([...header, ...tempoTrack, ...chordTrack, ...bassTrack]);

            // â”€â”€ Trigger download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            const key  = document.getElementById('key').value;
            const mode = document.getElementById('mode').value;
            const blob = new Blob([midi], { type: 'audio/midi' });
            const url  = URL.createObjectURL(blob);
            const a    = document.createElement('a');
            a.href     = url;
            a.download = `ambient-${key}-${mode}-${bpm}bpm.mid`;
            a.click();
            URL.revokeObjectURL(url);
        }
        (function() {
            const tooltip = document.getElementById('timeline-tooltip');
            const canvas = document.getElementById('canvas');

            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                // Scale mouse coords from CSS pixels to canvas pixels
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                let hit = null;
                let best = Infinity;
                timelineHitTargets.forEach(t => {
                    const dist = Math.sqrt((mx - t.x) ** 2 + (my - t.y) ** 2);
                    if (dist < t.r && dist < best) { best = dist; hit = t; }
                });

                if (hit) {
                    const lines = hit.label.split('\n');
                    tooltip.innerHTML = lines.map((l, i) => {
                        const color = i === 0
                            ? (hit.isBass ? '#7dd3fc' : '#d8b4fe')
                            : 'rgba(233,213,255,0.65)';
                        return `<span style="color:${color}">${l}</span>`;
                    }).join('<br>');
                    tooltip.style.borderColor = hit.isBass
                        ? 'rgba(56,189,248,0.6)'
                        : 'rgba(168,85,247,0.6)';

                    // Position tooltip â€” keep it inside viewport
                    const tw = 180, th = 70;
                    let tx = e.clientX + 14;
                    let ty = e.clientY - 10;
                    if (tx + tw > window.innerWidth - 8) tx = e.clientX - tw - 14;
                    if (ty + th > window.innerHeight - 8) ty = e.clientY - th - 10;
                    tooltip.style.left = tx + 'px';
                    tooltip.style.top = ty + 'px';
                    tooltip.classList.add('visible');
                    canvas.style.cursor = 'pointer';
                } else {
                    tooltip.classList.remove('visible');
                    canvas.style.cursor = 'crosshair';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });
        })();

        // Redraw on window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                drawTimeline();
            }, 100);
        });

        // â”€â”€ Playback Engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        let audioCtx = null;
        let isPlaying = false;
        let playbackNodes = [];
        let playbackLoopId = null;
        let playbackStartTime = 0;
        let playbackLoopLength = 0;
        let cursorAnimId = null;

        function getAudioCtx() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        // Build a simple impulse reverb
        function makeReverb(ctx) {
            const convolver = ctx.createConvolver();
            const rate = ctx.sampleRate;
            const length = rate * 3.5;
            const impulse = ctx.createBuffer(2, length, rate);
            for (let c = 0; c < 2; c++) {
                const ch = impulse.getChannelData(c);
                for (let i = 0; i < length; i++) {
                    ch[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.2);
                }
            }
            convolver.buffer = impulse;
            return convolver;
        }

        function schedulePlayback() {
            const ctx = getAudioCtx();
            const bpm = parseInt(document.getElementById('bpm').value);
            const secPerBeat = 60 / bpm;

            // Shared reverb + master gain
            const reverb = makeReverb(ctx);
            const reverbGain = ctx.createGain();
            reverbGain.gain.value = 0.45;
            reverb.connect(reverbGain);
            reverbGain.connect(ctx.destination);

            const dryGain = ctx.createGain();
            dryGain.gain.value = 0.55;
            dryGain.connect(ctx.destination);

            playbackNodes = [reverb, reverbGain, dryGain];

            const totalBeats = progression.reduce((s, c) => s + c.duration, 0);
            playbackLoopLength = totalBeats * secPerBeat;

            function scheduleLoop(loopStart) {
                // Read ADSR values from controls
                const envA = parseFloat(document.getElementById('envAttack').value);
                const envD = parseFloat(document.getElementById('envDecay').value);
                const envS = parseFloat(document.getElementById('envSustain').value);
                const envR = parseFloat(document.getElementById('envRelease').value);
                const peakGain = 0.18;
                const sustainGain = peakGain * envS;

                // â”€â”€ Chords â€” optionally tie repeated notes across chord changes â”€â”€
                const tieNotes = document.getElementById('tieNotes').checked;
                let tiedSegments = [];

                if (tieNotes) {
                    // Merge consecutive chords that share the same pitch into one held segment
                    let beatCursor = 0;
                    progression.forEach(chord => {
                        chord.notes.map(noteNameToMidi).forEach(midi => {
                            const existing = tiedSegments.find(
                                s => s.midi === midi && s.startBeat + s.durBeats === beatCursor
                            );
                            if (existing) {
                                existing.durBeats += chord.duration;
                            } else {
                                tiedSegments.push({ midi, startBeat: beatCursor, durBeats: chord.duration });
                            }
                        });
                        beatCursor += chord.duration;
                    });
                } else {
                    // One segment per note per chord â€” no tying
                    let beatCursor = 0;
                    progression.forEach(chord => {
                        chord.notes.map(noteNameToMidi).forEach(midi => {
                            tiedSegments.push({ midi, startBeat: beatCursor, durBeats: chord.duration });
                        });
                        beatCursor += chord.duration;
                    });
                }

                // Schedule one oscillator per tied segment
                tiedSegments.forEach(seg => {
                    const t   = loopStart + seg.startBeat * secPerBeat;
                    const dur = seg.durBeats * secPerBeat;

                    const totalEnv = envA + envD + envR;
                    const scale = totalEnv > dur ? dur / totalEnv : 1;
                    const attack  = envA * scale;
                    const decay   = envD * scale;
                    const release = envR * scale;
                    const sustainEnd = Math.max(t + attack + decay, t + dur - release);

                    const freq = 440 * Math.pow(2, (seg.midi - 69) / 12);
                    const osc = ctx.createOscillator();
                    const env = ctx.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    osc.detune.value = (Math.random() - 0.5) * 4;

                    env.gain.setValueAtTime(0, t);
                    env.gain.linearRampToValueAtTime(peakGain, t + attack);
                    env.gain.linearRampToValueAtTime(sustainGain, t + attack + decay);
                    env.gain.setValueAtTime(sustainGain, sustainEnd);
                    env.gain.linearRampToValueAtTime(0, t + dur);

                    osc.connect(env);
                    env.connect(dryGain);
                    env.connect(reverb);

                    osc.start(t);
                    osc.stop(t + dur + 0.05);
                    playbackNodes.push(osc, env);
                });

                // â”€â”€ Bass â”€â”€
                let bt = loopStart;
                bassLine.forEach(note => {
                    const dur = note.duration * secPerBeat;
                    if (!note.rest) {
                        const freq = 440 * Math.pow(2, (note.midi - 69) / 12);
                        const osc = ctx.createOscillator();
                        const env = ctx.createGain();

                        osc.type = 'sine';
                        osc.frequency.value = freq;

                        const attack = Math.min(dur * 0.15, 0.3);
                        const release = Math.min(dur * 0.3, 0.8);

                        env.gain.setValueAtTime(0, bt);
                        env.gain.linearRampToValueAtTime(0.28, bt + attack);
                        env.gain.setValueAtTime(0.28, bt + dur - release);
                        env.gain.linearRampToValueAtTime(0, bt + dur);

                        osc.connect(env);
                        env.connect(dryGain);
                        env.connect(reverb);

                        osc.start(bt);
                        osc.stop(bt + dur + 0.05);
                        playbackNodes.push(osc, env);
                    }
                    bt += dur;
                });
            }

            playbackStartTime = ctx.currentTime + 0.1;
            scheduleLoop(playbackStartTime);

            // Loop: schedule next iteration just before current one ends
            function checkLoop() {
                if (!isPlaying) return;
                if (!document.getElementById('loopPlayback').checked) {
                    // Stop when current loop finishes
                    const elapsed = audioCtx.currentTime - playbackStartTime;
                    if (elapsed >= playbackLoopLength) {
                        stopPlayback();
                        return;
                    }
                    playbackLoopId = setTimeout(checkLoop, 200);
                    return;
                }
                const elapsed = audioCtx.currentTime - playbackStartTime;
                const loopsCompleted = Math.floor(elapsed / playbackLoopLength);
                const nextLoopStart = playbackStartTime + (loopsCompleted + 1) * playbackLoopLength;

                // Schedule 0.5s ahead
                if (nextLoopStart - audioCtx.currentTime < 0.5) {
                    scheduleLoop(nextLoopStart);
                }
                playbackLoopId = setTimeout(checkLoop, 200);
            }
            playbackLoopId = setTimeout(checkLoop, 200);
        }

        function stopPlayback() {
            isPlaying = false;
            clearTimeout(playbackLoopId);
            cancelAnimationFrame(cursorAnimId);

            playbackNodes.forEach(n => {
                try { n.stop && n.stop(); } catch(e) {}
                try { n.disconnect(); } catch(e) {}
            });
            playbackNodes = [];

            // Clear cursor
            drawTimeline();

            const btn = document.getElementById('playBtn');
            btn.textContent = 'â–¶ Play';
            btn.classList.remove('playing');
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
                return;
            }
            if (progression.length === 0) return;

            isPlaying = true;
            const btn = document.getElementById('playBtn');
            btn.textContent = 'â–  Stop';
            btn.classList.add('playing');

            getAudioCtx().resume().then(() => {
                schedulePlayback();
                animateCursor();
            });
        }

        function animateCursor() {
            if (!isPlaying) return;

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const elapsed = audioCtx.currentTime - playbackStartTime;
            const looping = document.getElementById('loopPlayback').checked;
            const progress = looping
                ? (elapsed % playbackLoopLength) / playbackLoopLength
                : Math.min(elapsed / playbackLoopLength, 1);

            drawTimeline();

            const x = 10 + progress * (canvas.width - 20);
            ctx.save();
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.85)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(251, 191, 36, 0.6)';
            ctx.shadowBlur = 8;
            ctx.setLineDash([4, 3]);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            ctx.restore();

            if (!looping && elapsed >= playbackLoopLength) return; // cursor reached end
            cursorAnimId = requestAnimationFrame(animateCursor);
        }

        // Stop playback if progression regenerates
        const _origGenerate = generateProgression;
        generateProgression = function() {
            if (isPlaying) stopPlayback();
            _origGenerate();
        };
    </script>
</body>
</html>