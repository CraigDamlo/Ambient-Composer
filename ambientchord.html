<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Chord Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #581c87 50%, #0f172a 100%);
            min-height: 100vh;
            padding: 2rem;
            color: #e9d5ff;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .card {
            background: rgba(30, 27, 75, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }
        h1 { font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem; }
        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 0.5rem;
        }
        .btn-primary { background: #9333ea; color: white; }
        .btn-secondary { background: #16a34a; color: white; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0; }
        .control-group { display: flex; flex-direction: column; }
        label { font-size: 0.875rem; margin-bottom: 0.5rem; }
        select, input { 
            padding: 0.5rem; 
            background: #334155; 
            color: #e9d5ff; 
            border: 1px solid rgba(168, 85, 247, 0.3); 
            border-radius: 8px; 
        }
        .chord-item {
            padding: 1rem;
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 8px;
            margin-bottom: 0.75rem;
            display: flex;
            justify-content: space-between;
        }
        .chord-name { font-size: 1.5rem; font-weight: bold; }
        .timeline-wrapper { 
            background: rgba(15, 23, 42, 0.8); 
            border-radius: 8px; 
            padding: 2rem; 
            padding-left: 80px;
            overflow-x: auto; 
        }
        #timeline { 
            position: relative; 
            min-width: 900px; 
            height: 400px; 
        }
        .note-labels {
            position: absolute;
            left: -60px;
            top: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .grid-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(168, 85, 247, 0.15);
        }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>Ambient Chord Progression Generator</h1>
            <p style="color: rgba(233, 213, 255, 0.7); margin-bottom: 1.5rem;">
                Generate evolving chord progressions for your hardware synths
            </p>
            
            <div>
                <button class="btn-primary" onclick="generateProgression()">â†» Generate New</button>
                <button class="btn-secondary" onclick="exportProgression()">ðŸ“‹ Copy to Clipboard</button>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Key</label>
                    <select id="key" onchange="generateProgression()">
                        <option>C</option><option>C#</option><option>D</option><option>D#</option>
                        <option>E</option><option>F</option><option>F#</option><option>G</option>
                        <option>G#</option><option>A</option><option>A#</option><option>B</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Mode</label>
                    <select id="mode" onchange="generateProgression()">
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="dorian">Dorian</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Voicing Mode</label>
                    <select id="voicingMode" onchange="updateVoicingControls(); generateProgression()">
                        <option value="fixed">Fixed</option>
                        <option value="varied">Varied</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Length: <span id="lengthVal">4</span></label>
                    <input type="range" id="length" min="2" max="8" value="4" 
                           oninput="document.getElementById('lengthVal').textContent=this.value; generateProgression()">
                </div>
                <div class="control-group">
                    <label>Change Rate: <span id="rateVal">4</span> beats</label>
                    <input type="range" id="rate" min="2" max="16" step="2" value="4"
                           oninput="document.getElementById('rateVal').textContent=this.value; generateProgression()">
                </div>
            </div>

            <div id="voicingFixed" class="control-group" style="margin-bottom: 1rem; display: none;">
                <label>Fixed Voicing Type</label>
                <select id="fixedVoicing" onchange="generateProgression()">
                    <option value="triad">Triad (3 notes)</option>
                    <option value="seventh" selected>7th (4 notes)</option>
                    <option value="ninth">9th (5 notes)</option>
                    <option value="eleventh">11th (6 notes)</option>
                </select>
            </div>

            <div id="voicingVaried" class="control-group" style="margin-bottom: 1rem; display: none;">
                <label>Voicing Complexity: <span id="varietyVal">50</span>%</label>
                <input type="range" id="variety" min="0" max="1" step="0.1" value="0.5"
                       oninput="document.getElementById('varietyVal').textContent=Math.round(this.value*100); generateProgression()">
            </div>

            <div class="control-group" style="margin-bottom: 1rem;">
                <label>Timing Complexity: <span id="complexityVal">30</span>%</label>
                <input type="range" id="complexity" min="0" max="1" step="0.1" value="0.3"
                       oninput="document.getElementById('complexityVal').textContent=Math.round(this.value*100); generateProgression()">
            </div>

            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="inversions" checked onchange="generateProgression()">
                <label for="inversions">Smart Inversions (smooth voice leading and loops)</label>
            </div>
        </div>

        <div class="card">
            <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">Current Progression</h2>
            <div id="loopQuality" style="margin-bottom: 1rem; padding: 1rem; background: rgba(168, 85, 247, 0.1); border-radius: 8px;"></div>
            <div id="progressionList"></div>
        </div>

        <div class="card">
            <h2 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">Timeline View</h2>
            <div class="timeline-wrapper">
                <div id="timeline">
                    <canvas id="canvas" width="900" height="400"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let progression = [];
        
        const chordLibrary = {
            major: {
                I: { triad: [0,4,7], seventh: [0,4,7,11], ninth: [0,4,7,11,14], eleventh: [0,4,7,11,14,17] },
                ii: { triad: [2,5,9], seventh: [2,5,9,12], ninth: [2,5,9,12,16], eleventh: [2,5,9,12,16,19] },
                iii: { triad: [4,7,11], seventh: [4,7,11,14], ninth: [4,7,11,14,16], eleventh: [4,7,11,14,16,19] },
                IV: { triad: [5,9,12], seventh: [5,9,12,16], ninth: [5,9,12,16,19], eleventh: [5,9,12,16,19,22] },
                V: { triad: [7,11,14], seventh: [7,11,14,17], ninth: [7,11,14,17,21], eleventh: [7,11,14,17,21,24] },
                vi: { triad: [9,12,16], seventh: [9,12,16,19], ninth: [9,12,16,19,21], eleventh: [9,12,16,19,21,24] },
                'viiÂ°': { triad: [11,14,17], seventh: [11,14,17,20], ninth: [11,14,17,20,23], eleventh: [11,14,17,20,23,26] }
            },
            minor: {
                i: { triad: [0,3,7], seventh: [0,3,7,10], ninth: [0,3,7,10,14], eleventh: [0,3,7,10,14,17] },
                'iiÂ°': { triad: [2,5,8], seventh: [2,5,8,12], ninth: [2,5,8,12,15], eleventh: [2,5,8,12,15,19] },
                III: { triad: [3,7,10], seventh: [3,7,10,14], ninth: [3,7,10,14,17], eleventh: [3,7,10,14,17,20] },
                iv: { triad: [5,8,12], seventh: [5,8,12,15], ninth: [5,8,12,15,19], eleventh: [5,8,12,15,19,22] },
                v: { triad: [7,10,14], seventh: [7,10,14,17], ninth: [7,10,14,17,19], eleventh: [7,10,14,17,19,22] },
                VI: { triad: [8,12,15], seventh: [8,12,15,19], ninth: [8,12,15,19,22], eleventh: [8,12,15,19,22,24] },
                VII: { triad: [10,14,17], seventh: [10,14,17,20], ninth: [10,14,17,20,22], eleventh: [10,14,17,20,22,24] }
            },
            dorian: {
                i: { triad: [0,3,7], seventh: [0,3,7,10], ninth: [0,3,7,10,14], eleventh: [0,3,7,10,14,17] },
                ii: { triad: [2,5,9], seventh: [2,5,9,12], ninth: [2,5,9,12,16], eleventh: [2,5,9,12,16,19] },
                III: { triad: [3,7,10], seventh: [3,7,10,14], ninth: [3,7,10,14,17], eleventh: [3,7,10,14,17,19] },
                IV: { triad: [5,9,12], seventh: [5,9,12,16], ninth: [5,9,12,16,19], eleventh: [5,9,12,16,19,21] },
                v: { triad: [7,10,14], seventh: [7,10,14,17], ninth: [7,10,14,17,19], eleventh: [7,10,14,17,19,21] },
                'viÂ°': { triad: [9,12,15], seventh: [9,12,15,19], ninth: [9,12,15,19,21], eleventh: [9,12,15,19,21,24] },
                VII: { triad: [10,14,17], seventh: [10,14,17,21], ninth: [10,14,17,21,24], eleventh: [10,14,17,21,24,26] }
            }
        };

        const commonProgressions = {
            major: [['I','V','vi','IV'], ['I','vi','IV','V'], ['I','IV','V','IV'], ['vi','IV','I','V']],
            minor: [['i','VI','III','VII'], ['i','iv','VII','VI'], ['i','VI','VII','i']],
            dorian: [['i','IV','i','IV'], ['i','ii','IV','i'], ['i','VII','IV','i']]
        };

        function noteToMidi(note, octave = 3) {
            const map = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
            return map[note] + (octave + 1) * 12;
        }

        function midiToNote(midi) {
            const notes = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
            return notes[midi % 12] + (Math.floor(midi / 12) - 1);
        }

        function noteNameToMidi(name) {
            const match = name.match(/([A-G]#?)(\d+)/);
            if (!match) return 60;
            const map = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11};
            return map[match[1]] + (parseInt(match[2]) + 1) * 12;
        }

        function findBestInversion(chord, prevChord) {
            if (!prevChord || prevChord.length === 0) return chord;
            
            const inversions = [];
            for (let i = 0; i < chord.length; i++) {
                const inv = [...chord];
                for (let j = 0; j < i; j++) {
                    inv.push(inv.shift() + 12);
                }
                inversions.push(inv);
            }
            
            let best = inversions[0];
            let minDist = Infinity;
            
            inversions.forEach(inv => {
                let dist = 0;
                const voices = Math.min(inv.length, prevChord.length);
                for (let i = 0; i < voices; i++) {
                    dist += Math.abs(inv[i] - prevChord[i]);
                }
                if (dist < minDist) {
                    minDist = dist;
                    best = inv;
                }
            });
            
            return best;
        }

        function updateVoicingControls() {
            const mode = document.getElementById('voicingMode').value;
            document.getElementById('voicingFixed').style.display = mode === 'fixed' ? 'block' : 'none';
            document.getElementById('voicingVaried').style.display = mode === 'varied' ? 'block' : 'none';
        }

        function generateProgression() {
            const key = document.getElementById('key').value;
            const mode = document.getElementById('mode').value;
            const voicingMode = document.getElementById('voicingMode').value;
            const fixedVoicing = document.getElementById('fixedVoicing').value;
            const variety = parseFloat(document.getElementById('variety').value);
            const length = parseInt(document.getElementById('length').value);
            const rate = parseInt(document.getElementById('rate').value);
            const complexity = parseFloat(document.getElementById('complexity').value);
            const useInversions = document.getElementById('inversions').checked;

            const baseProgression = commonProgressions[mode][Math.floor(Math.random() * commonProgressions[mode].length)];
            const rootMidi = noteToMidi(key);
            const voicingTypes = ['triad', 'seventh', 'ninth', 'eleventh'];
            const chordsToUse = baseProgression.slice(0, length);

            const tempChords = [];
            chordsToUse.forEach(chordName => {
                const voicings = chordLibrary[mode][chordName];
                
                let selectedVoicing;
                if (voicingMode === 'fixed') {
                    selectedVoicing = fixedVoicing;
                } else if (voicingMode === 'varied') {
                    const r = Math.random();
                    if (r < (1 - variety) * 0.5) selectedVoicing = 'triad';
                    else if (r < (1 - variety) * 0.7 + variety * 0.3) selectedVoicing = 'seventh';
                    else if (r < (1 - variety) * 0.85 + variety * 0.6) selectedVoicing = 'ninth';
                    else selectedVoicing = 'eleventh';
                } else {
                    selectedVoicing = voicingTypes[Math.floor(Math.random() * voicingTypes.length)];
                }
                
                const intervals = voicings[selectedVoicing];
                const midi = intervals.map(i => rootMidi + i);
                
                let duration = rate;
                if (Math.random() < complexity) {
                    duration = [2, 4, 8][Math.floor(Math.random() * 3)];
                }
                
                tempChords.push({ name: chordName, voicing: selectedVoicing, rootMidi: midi, duration });
            });

            if (useInversions && tempChords.length > 1) {
                let bestSeq = null;
                let bestDist = Infinity;
                
                for (let firstInv = 0; firstInv < tempChords[0].rootMidi.length; firstInv++) {
                    const first = [...tempChords[0].rootMidi];
                    for (let i = 0; i < firstInv; i++) {
                        first.push(first.shift() + 12);
                    }
                    
                    const seq = [first];
                    let totalDist = 0;
                    
                    for (let i = 1; i < tempChords.length; i++) {
                        const next = findBestInversion(tempChords[i].rootMidi, seq[i - 1]);
                        seq.push(next);
                        
                        const voices = Math.min(seq[i - 1].length, next.length);
                        for (let v = 0; v < voices; v++) {
                            totalDist += Math.abs(next[v] - seq[i - 1][v]);
                        }
                    }
                    
                    const last = seq[seq.length - 1];
                    const voices = Math.min(last.length, first.length);
                    for (let v = 0; v < voices; v++) {
                        totalDist += Math.abs(first[v] - last[v]);
                    }
                    
                    if (totalDist < bestDist) {
                        bestDist = totalDist;
                        bestSeq = seq.map(s => [...s]);
                    }
                }
                
                if (bestSeq) {
                    progression = tempChords.map((chord, idx) => {
                        const midi = bestSeq[idx];
                        const lowest = midi[0] % 12;
                        const root = chord.rootMidi[0] % 12;
                        
                        let inversion = 'root';
                        if (lowest !== root) {
                            const invIdx = chord.rootMidi.findIndex(n => (n % 12) === lowest);
                            if (invIdx === 1) inversion = '1st';
                            else if (invIdx === 2) inversion = '2nd';
                            else if (invIdx === 3) inversion = '3rd';
                            else if (invIdx > 0) inversion = invIdx + 'th';
                        }
                        
                        return {
                            name: chord.name,
                            notes: midi.map(midiToNote),
                            voicing: chord.voicing,
                            inversion,
                            duration: chord.duration
                        };
                    });
                }
            } else {
                progression = tempChords.map(chord => ({
                    name: chord.name,
                    notes: chord.rootMidi.map(midiToNote),
                    voicing: chord.voicing,
                    inversion: 'root',
                    duration: chord.duration
                }));
            }

            displayProgression();
            drawTimeline();
        }

        function displayProgression() {
            const list = document.getElementById('progressionList');
            const useInv = document.getElementById('inversions').checked;
            
            list.innerHTML = progression.map(c => `
                <div class="chord-item">
                    <div>
                        <span class="chord-name">${c.name}</span>
                        <span style="color: #d8b4fe; margin-left: 1rem;">${c.notes.join(' - ')}</span>
                        <span style="color: rgba(233,213,255,0.6); font-size: 0.875rem; margin-left: 0.75rem;">
                            (${c.voicing}${useInv ? ', ' + c.inversion + ' inv' : ''})
                        </span>
                    </div>
                    <div style="font-family: monospace; color: #d8b4fe;">${c.duration} beats</div>
                </div>
            `).join('');
            
            // Show loop quality
            if (progression.length > 0 && useInv) {
                const first = progression[0].notes.map(noteNameToMidi);
                const last = progression[progression.length - 1].notes.map(noteNameToMidi);
                
                let totalDist = 0;
                const voices = Math.min(first.length, last.length);
                for (let i = 0; i < voices; i++) {
                    totalDist += Math.abs(first[i] - last[i]);
                }
                const avgDist = (totalDist / voices).toFixed(1);
                
                const quality = document.getElementById('loopQuality');
                if (avgDist < 3) {
                    quality.innerHTML = `<strong>Loop Quality: Excellent âœ“</strong><br>Average distance: ${avgDist} semitones (very smooth loop)`;
                    quality.style.background = 'rgba(34, 197, 94, 0.2)';
                } else if (avgDist < 6) {
                    quality.innerHTML = `<strong>Loop Quality: Good</strong><br>Average distance: ${avgDist} semitones (smooth loop)`;
                    quality.style.background = 'rgba(234, 179, 8, 0.2)';
                } else {
                    quality.innerHTML = `<strong>Loop Quality: Fair</strong><br>Average distance: ${avgDist} semitones (moderate jump)`;
                    quality.style.background = 'rgba(239, 68, 68, 0.2)';
                }
                
                // Show individual voice movements
                const details = [];
                for (let i = 0; i < voices; i++) {
                    const dist = Math.abs(first[i] - last[i]);
                    details.push(`Voice ${i + 1}: ${dist} semitones`);
                }
                quality.innerHTML += `<br><span style="font-size: 0.875rem; color: rgba(233, 213, 255, 0.7);">${details.join(' â€¢ ')}</span>`;
            } else {
                document.getElementById('loopQuality').innerHTML = '';
            }
        }

        function drawTimeline() {
            if (progression.length === 0) return;
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const width = 900;
            const height = 400;
            const padding = 10;
            
            ctx.clearRect(0, 0, width, height);
            
            const totalBeats = progression.reduce((sum, c) => sum + c.duration, 0);
            let allMidi = [];
            progression.forEach(c => c.notes.forEach(n => allMidi.push(noteNameToMidi(n))));
            
            const minNote = Math.min(...allMidi) - 1;
            const maxNote = Math.max(...allMidi) + 1;
            
            let time = 0;
            const positions = progression.map(c => {
                const x = padding + (time / totalBeats) * (width - padding);
                const notes = c.notes.map(n => {
                    const midi = noteNameToMidi(n);
                    const y = ((maxNote - midi) / (maxNote - minNote)) * height;
                    return { midi, y };
                });
                time += c.duration;
                return { x, notes, chord: c };
            });
            
            // Draw lines
            ctx.lineWidth = 2.5;
            for (let i = 0; i < positions.length - 1; i++) {
                const curr = positions[i];
                const next = positions[i + 1];
                const maxVoices = Math.max(curr.notes.length, next.notes.length);
                
                for (let v = 0; v < maxVoices; v++) {
                    if (v < curr.notes.length && v < next.notes.length) {
                        const grad = ctx.createLinearGradient(curr.x, curr.notes[v].y, next.x, next.notes[v].y);
                        grad.addColorStop(0, 'rgba(168, 85, 247, 0.7)');
                        grad.addColorStop(1, 'rgba(139, 92, 246, 0.7)');
                        ctx.strokeStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(curr.x, curr.notes[v].y);
                        ctx.lineTo(next.x, next.notes[v].y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw dots
            positions.forEach(pos => {
                pos.notes.forEach(note => {
                    ctx.fillStyle = 'rgba(168, 85, 247, 0.3)';
                    ctx.beginPath();
                    ctx.arc(pos.x, note.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#8b5cf6';
                    ctx.beginPath();
                    ctx.arc(pos.x, note.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
            
            // Draw grid and labels
            const timeline = document.getElementById('timeline');
            timeline.querySelectorAll('.note-labels, .grid-line').forEach(el => el.remove());
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'note-labels';
            for (let midi = maxNote; midi >= minNote; midi--) {
                const label = document.createElement('div');
                label.textContent = midiToNote(midi);
                label.style.color = '#d8b4fe';
                label.style.fontSize = '0.875rem';
                label.style.fontFamily = 'monospace';
                labelDiv.appendChild(label);
            }
            timeline.appendChild(labelDiv);
            
            for (let midi = maxNote; midi >= minNote; midi--) {
                const line = document.createElement('div');
                line.className = 'grid-line';
                line.style.top = ((maxNote - midi) / (maxNote - minNote)) * height + 'px';
                timeline.appendChild(line);
            }
        }

        function exportProgression() {
            const useInv = document.getElementById('inversions').checked;
            const key = document.getElementById('key').value;
            const mode = document.getElementById('mode').value;
            
            const text = `Key: ${key} ${mode}
Smart Inversions: ${useInv ? 'Enabled' : 'Disabled'}
Total Loop Length: ${progression.reduce((s, c) => s + c.duration, 0)} beats

Progression:
${progression.map((c, i) => `${i + 1}. ${c.name} [${c.voicing}${useInv ? ', ' + c.inversion + ' inv' : ''}] - ${c.notes.join(', ')} - ${c.duration} beats`).join('\n')}`;
            
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            }).catch(() => {
                alert('Could not copy to clipboard');
            });
        }

        updateVoicingControls();
        generateProgression();
    </script>
</body>
</html>